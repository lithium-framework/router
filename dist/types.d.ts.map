{"mappings":";;AAcA;IACE,IAAI,CAAC,EAAE,MAAM,GAAG,SAAS,CAAC;IAC1B,MAAM,CAAC,EAAE,aAAa;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS,CAAA;KAAE,CAAC,CAAC;IAC7D,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE;QACb,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS,CAAC;KACrC,KAAK,OAAO,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC;CAClC;AAOD,gCAAiC,SAAQ,eAAe;IACtD,IAAI,EAAE,MAAM,CAAC;CACd;AAOD,sCAAuC,SAAQ,eAAe;IAC5D,OAAO,EAAE,UAAU,CAAC;CACrB;AAED,0BAA0B,eAAe,GAAG,OAAO,CAAC,qBAAqB,CAAC,CAAC;AAI3E,mBAAoB,SAAQ,eAAe;IAEzC,WAAW,EAAC,GAAG,CAAC;gBAEH,MAAM,EAAC,oBAAoB,EAAG,WAAW,EAAC,WAAW,EAAE;CAkBrE;AAID,iCAIkC,SAAQ,YAAY;IAMpD,IAAI,EAAG,iBAAiB,GAAG,aAAa,CAAiB;IAYzD,MAAM,EAAC,aAAa,oBAAoB,CAAC,CAAC;IAC1C,MAAM,EAAC,aAAa,oBAAoB,CAAC,CAAC;IAE1C,IAAI,MAAM,WAKT;IAED,IAAI,MAAM,IAIY,WAAW,EAAE,CAFlC;IAED,IAAI,MAAM,CAAE,SAAS,EAAC,WAAW,EAAE,EAGlC;gBAEY,MAAM,EAAC,WAAW,EAAE;IAKjC,MAAM;IAkBN,YAAY,CAAE,KAAK,EAAC,eAAe;IAInC,qBAAqB,CAAE,IAAI,EAAC,MAAM;IAIlC,IAAI,QAAQ,WAEX;IAED,IAAI,IAAI,WAEP;IAED,KAAK;IAML,iBAAiB,IAAI,IAAI;CAc1B;AAED,OAAO,EACL,eAAe,EAChB,CAAA;AAED,yBAAsB,MAAM,CAAA;IAC1B,UAAU,qBAAqB;QAC7B,gBAAgB,EAAG,OAAO,oBAAoB,CAAC;KAChD;CACF","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { render , customElement , WebComponent , ViewTemplate , html } from '@lithium-framework/core';\nimport RouteRecognizer, { Params } from 'route-recognizer';\n\nif ('URLPattern' in globalThis == false) { \n  import(\"urlpattern-polyfill\").then(({ URLPattern }) => {\n    Object.defineProperty( window , 'URLPattern' , {\n      get(){ return URLPattern }\n    } )\n  })\n}\n\n/* The `BaseRouteConfig` interface is defining a structure for the configuration options that can be\nprovided for a route in the routing system. Here's a breakdown of each property within the\n`BaseRouteConfig` interface: */\nexport interface BaseRouteConfig {\n  name?: string | undefined;\n  render?: ViewTemplate<{ [key: string]: string | undefined }>;\n  enter?: (params: {\n      [key: string]: string | undefined;\n  }) => Promise<boolean> | boolean;\n}\n\n/* The `interface PathRouteConfig` is extending the `BaseRouteConfig` interface and adding a new\nproperty `path` of type string to it. This means that any object that implements the\n`PathRouteConfig` interface must have all the properties defined in `BaseRouteConfig` interface\n(like `name`, `render`, `enter`) along with the additional `path` property of type string. This\nallows for more specific route configurations that include a path string for routing purposes. */\nexport interface PathRouteConfig extends BaseRouteConfig {\n  path: string;\n}\n\n/* The `interface URLPatternRouteConfig` is extending the `BaseRouteConfig` interface by adding a new\nproperty `pattern` of type `URLPattern` to it. This means that any object that implements the\n`URLPatternRouteConfig` interface must have all the properties defined in the `BaseRouteConfig`\ninterface (such as `name`, `render`, `enter`) along with the additional `pattern` property of type\n`URLPattern`. */\nexport interface URLPatternRouteConfig extends BaseRouteConfig {\n  pattern: URLPattern;\n}\n\nexport type RouteConfig = PathRouteConfig & Partial<URLPatternRouteConfig>;\n\n/* The `Routes` class extends `RouteRecognizer` and constructs routes based on the provided\n`routeConfig` array. */\nexport class Routes extends RouteRecognizer{\n\n  routeConfig:any;\n\n  constructor( router:LithiumRouterElement , routeConfig:RouteConfig[] ){\n    super();\n\n    routeConfig.forEach(( route:RouteConfig ) => {\n\n      this.add([\n        { \n          path : route.path , \n          handler : ( params:any ) => {\n            render( route.render , router , params )\n          },\n        }\n      ] , \n      route.name ? { as : route.name } : null as any)\n    })\n\n  }\n\n}\n\n/* The `Router` class is a custom web component that handles routing based on either pathname or hash,\nwith configurable routes and templates for header and footer. */\n@customElement({\n  name : \"lithium-router\",\n  template : html`<slot></slot>`\n})\nexport class LithiumRouterElement extends WebComponent{\n\n  /* The line `type : 'pathname-router' | 'hash-router' = 'hash-router';` is defining a property `type`\n  in the `Router` class with a type of string literal union `'pathname-router' | 'hash-router'`.\n  This means that the `type` property can only have one of two specific string values:\n  `'pathname-router'` or `'hash-router'`. */\n  type : 'pathname-router' | 'hash-router' = 'hash-router';\n\n  /* `private _config:RouteConfig[] = [];` is defining a private property `_config` in the `Router`\n  class with an initial value of an empty array of `RouteConfig` objects. This property is used to\n  store the route configuration provided to the `Router` instance. */\n  private _config:RouteConfig[] = [];\n\n  /* The line `private _routes = new Routes(this, this._config || []);` is initializing a private\n  property `_routes` in the `Router` class with a new instance of the `Routes` class. The `Routes`\n  class is responsible for constructing routes based on the provided `routeConfig` array. */\n  private _routes = new Routes(this, this._config || []);\n\n  header:ViewTemplate<LithiumRouterElement>;\n  footer:ViewTemplate<LithiumRouterElement>;\n\n  get routes(){\n    return new Proxy( this._routes , {\n      get(){ return undefined; },\n      set(){ return false; }\n    } )\n  }\n\n  get config(){\n    return this._config;\n  }\n\n  set config( newConfig:RouteConfig[] ){\n    this._config = newConfig;\n    this._routes = new Routes(this, newConfig || []);\n  }\n\n  constructor( config:RouteConfig[] ){\n    super();\n    this.config = config;\n  }\n\n  outlet(){\n\n    this.clear();\n    let url = this.type == 'pathname-router' ? this.pathname : this.hash;\n    let result = this._routes.recognize( url );\n\n    if(result)Array.from( { length : result.length } , ( i , iterator ) => {\n\n      let route = result[iterator];\n      if(route){\n        let handler = route.handler as ( params:Params ) => void;\n        handler( route.params );\n      }\n\n    });\n\n  }\n\n  onHashChange( event:HashChangeEvent ){\n    this.outlet();\n  }\n\n  normalizeHashLocation( hash:string ){\n    return hash.replace('#' , '');\n  }\n\n  get pathname(){\n    return window.location.pathname;\n  }\n\n  get hash(){\n    return this.normalizeHashLocation( window.location.hash );\n  }\n\n  clear(){\n    this.childNodes.forEach((element) => {\n      element.remove();\n    })\n  }\n\n  connectedCallback(): void {\n\n    super.connectedCallback();\n\n    if(this.type == 'hash-router'){\n      window.addEventListener( 'hashchange' , this.onHashChange.bind(this) );\n    }\n\n    this.outlet();\n\n    if(!window.location.hash)window.location.hash = '/';\n\n  }\n\n};\n\nexport {\n  RouteRecognizer\n}\n\nexport declare module global{\n  interface HTMLElementTagNameMap{\n    'lithium-router' : typeof LithiumRouterElement;\n  }\n}"],"names":[],"version":3,"file":"types.d.ts.map"}