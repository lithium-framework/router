{"mappings":";AAIA,8BAI+B,SAAQ,YAAY;IACzC,IAAI,EAAE,MAAM,CAAM;IACjB,OAAO,EAAE,GAAG,CAAQ;IAG7B,UAAU,CAAC,QAAQ,EAAE,GAAG;IAKxB,QAAQ;IAUR,UAAU;CAGX;AAeD,uBAKwB,SAAQ,YAAY;IAE/B,YAAY,SAAM;IAE3B,iBAAiB;IAOjB,WAAW;IAMX,qBAAqB;CAexB;AAED,QAAQ,MAAM,CAAC;IACb,UAAU,WAAW;QACjB,aAAa,EAAE,UAAU,CAAC;QAC1B,qBAAqB,EAAE,iBAAiB,CAAC;KAC5C;CACF","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { WebComponent, html, css, customElement, attr , state , render } from \"@lithium-framework/core\";\n\n// Chaque élément correspond à une vue spécifique, identifiable via l'attribut `path`.\n// Les callbacks sont appelés lorsque la route est activée.\n@customElement({\n  name: 'hash-router-element',\n  template: html`<slot></slot>` // Contenu via slot dynamique\n})\nexport class HashRouterElement extends WebComponent {\n  @attr() path: string = \"\";\n  @state() element: any = null; // Stocke le modèle (template)\n\n  // Méthode pour définir un template à rendre lors de l'activation de la route\n  setElement(template: any) {\n    this.element = template;\n  }\n\n  // Méthode appelée lorsque la route devient active\n  activate() {\n    // Utiliser Lithium pour rendre le contenu dynamique\n    this.innerHTML = \"\"; // Vider le contenu précédent\n    if (this.element) {\n      render(this.element, this); // Rendre le template dans l'élément\n    }\n    this.style.display = 'block';  // Affiche l'élément\n  }\n\n  // Méthode appelée lorsque la route devient inactive\n  deactivate() {\n    this.style.display = 'none'; // Masque l'élément\n  }\n}\n\n// Template pour `hash-router`\nconst routerTemplate = html<HashRouter>`\n    <slot></slot>\n`;\n\n// Styles pour `hash-router` (optionnel)\nconst routerStyles = css`\n    :host {\n        display: block;\n    }\n`;\n\n// Définition de `hash-router`\n@customElement({\n    name: 'hash-router',\n    template: routerTemplate,\n    styles: routerStyles\n})\nexport class HashRouter extends WebComponent {\n\n    @state() currentRoute = \"\"; // La route actuelle\n\n    connectedCallback() {\n        super.connectedCallback();\n        this.updateRoute();\n        window.addEventListener('hashchange', () => this.updateRoute());\n    }\n\n    // Fonction qui met à jour la route en fonction du hash de l'URL\n    updateRoute() {\n        this.currentRoute = window.location.hash || \"#\";\n        this.updateVisibleElements();\n    }\n\n    // Fonction qui gère l'affichage et les callbacks des éléments enfants\n    updateVisibleElements() {\n        const children = Array.from(this.children) as HashRouterElement[];\n\n        children.forEach((child) => {\n            // Si l'élément est un `hash-router-element`\n            if (child instanceof HashRouterElement) {\n                // Activer l'élément si son path correspond à la route\n                if (child.getAttribute(\"path\") === this.currentRoute) {\n                    child.activate();\n                } else {\n                    child.deactivate();\n                }\n            }\n        });\n    }\n}\n\ndeclare global {\n  interface NamedTagMap {\n      'hash-router': HashRouter;\n      'hash-router-element': HashRouterElement;\n  }\n}"],"names":[],"version":3,"file":"types.d.ts.map"}