{"mappings":";AAKA;;EAEC;AAED,8BAW+B,SAAQ,YAAY;IACzC,IAAI,EAAE,MAAM,CAAM;IACjB,OAAO,EAAE,GAAG,CAAQ;IACpB,MAAM,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAM;IAEhD,UAAU,CAAC,QAAQ,EAAE,GAAG;IAKxB,QAAQ,CAAC,MAAM,GAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAO;IAc/C,UAAU;CAGX;AAYD,uBAKwB,SAAQ,YAAY;IACjC,YAAY,SAAM;IAE3B,iBAAiB;IAMjB,WAAW;IAOX,UAAU,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG;QAAE,OAAO,EAAE,OAAO,CAAC;QAAC,MAAM,EAAE;YAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;SAAE,CAAA;KAAE;IAgChG,qBAAqB;CAqBtB;AAED,QAAQ,MAAM,CAAC;IACb,UAAU,WAAW;QACnB,aAAa,EAAE,UAAU,CAAC;QAC1B,qBAAqB,EAAE,iBAAiB,CAAC;KAC1C;CACF","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { WebComponent, html, css, customElement, attr, state, render } from \"@lithium-framework/core\";\n\nlet routeParams: { [key: string]: string } = {};\n\n// Fonction pour accéder aux paramètres de la route\nexport function useParams() {\n  return routeParams;\n}\n\n@customElement({\n  name: 'hash-router-element',\n  template: html`<slot></slot>`,\n  styles : [\n    css`\n      :host{\n        display : block;\n      }\n    `\n  ]\n})\nexport class HashRouterElement extends WebComponent {\n  @attr() path: string = \"\";\n  @state() element: any = null;\n  @state() params: { [key: string]: string } = {};  // Nouvel état pour stocker les paramètres\n\n  setElement(template: any) {\n    this.element = template;\n  }\n\n  // Méthode appelée avec les paramètres lorsque la route devient active\n  activate(params: { [key: string]: string } = {}) {\n    this.params = params;\n\n    this.childNodes.forEach(( child ) => {\n      child.remove();\n    })\n\n    // this.innerHTML = \"\"; // Vider le contenu précédent\n    if (this.element) {\n      render(this.element, this);\n    }\n    this.style.display = 'block';\n  }\n\n  deactivate() {\n    this.style.display = 'none';\n  }\n}\n\nconst routerTemplate = html<HashRouter>`\n  <slot></slot>\n`;\n\nconst routerStyles = css`\n  :host{\n    display : block;\n  }\n`;\n\n@customElement({\n  name: 'hash-router',\n  template: routerTemplate,\n  styles: routerStyles\n})\nexport class HashRouter extends WebComponent {\n  @state() currentRoute = \"\";\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.updateRoute();\n    window.addEventListener('hashchange', () => this.updateRoute());\n  }\n\n  updateRoute() {\n    this.currentRoute = window.location.hash.replace('#' , '') || \"/\";\n\n    this.updateVisibleElements();\n  }\n\n  // Fonction pour vérifier si le path correspond à la route actuelle et extraire les paramètres\n  matchRoute(path: string, route: string): { matched: boolean; params: { [key: string]: string } } {\n\n    console.log( { operationId : \"matchRoute\" , path , route } )\n\n    const routeSegments = route.split('/');\n    const pathSegments = path.replace('/#' , '').split('/');\n    const params: { [key: string]: string } = {};\n\n    // Vérifier si le nombre de segments est différent\n    if (routeSegments.length !== pathSegments.length) {\n        return { matched: false, params: {} };\n    }\n\n    // Parcourir chaque segment pour vérifier le match\n    for (let i = 0; i < routeSegments.length; i++) {\n        if (routeSegments[i].startsWith(\":\")) {\n            // Si le segment de chemin commence par ':', on l'interprète comme un paramètre\n            const paramName = routeSegments[i].slice(1); // Supprimer ':' pour obtenir le nom du paramètre\n            params[paramName] = pathSegments[i];       // Associer la valeur au paramètre\n        } else if (pathSegments[i] !== routeSegments[i]) {\n            // Si les segments ne correspondent pas exactement et que ce n'est pas un paramètre, le match échoue\n            console.log( \"wrong segment\" , { 1 : pathSegments[i] , 2 : routeSegments[i] })\n            return { matched: false, params: {} };\n        }\n    }\n\n    console.log({ matched: true, params })\n\n    return { matched: true, params }; // Retourner le match et les paramètres extraits\n  }\n\n  // Mettre à jour l'affichage en fonction de la route et des paramètres\n  updateVisibleElements() {\n    const children = Array.from(this.children) as HashRouterElement[];\n    let matchedRoute = false;\n\n    children.forEach((child) => {\n      if (child instanceof HashRouterElement) {\n        const { matched, params } = this.matchRoute(this.currentRoute, child.path.replace('#' , '') );\n        if (matched) {\n          child.activate(params);\n          routeParams = params;  // Met à jour les paramètres dans la variable globale\n          matchedRoute = true;\n        } else {\n          child.deactivate();\n        }\n      }\n    });\n\n    if (!matchedRoute) {\n      routeParams = {};  // Nettoie la variable globale si aucune route n'est trouvée\n    }\n  }\n}\n\ndeclare global {\n  interface NamedTagMap {\n    'hash-router': HashRouter;\n    'hash-router-element': HashRouterElement;\n  }\n}"],"names":[],"version":3,"file":"types.d.ts.map","sourceRoot":"../"}